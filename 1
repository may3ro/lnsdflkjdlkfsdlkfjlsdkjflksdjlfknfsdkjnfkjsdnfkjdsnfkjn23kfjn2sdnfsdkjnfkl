param(
    [Parameter(Mandatory=$true)]
    [string]$ServerUrl,
    
    [Parameter(Mandatory=$true)]
    [string]$Token,
    
    [Parameter(Mandatory=$true)]
    [string]$ProjectKey,
    
    [Parameter(Mandatory=$true)]
    [string]$OutputPath,
    
    [int]$SnippetLinesBefore = 3,
    
    [int]$SnippetLinesAfter = 3,
    
    [int]$PageSize = 100,  # Safer default
    
    [switch]$IncludeResolved  # New: Include fixed issues?
)

Write-Host "Starting export for Project: $ProjectKey" -ForegroundColor Green

# Headers
$headers = @{
    'Authorization' = "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$Token")))"
    'Accept' = 'application/json'
}

# Test connection
$testUri = "$ServerUrl/api/projects/search"
try {
    $testResp = Invoke-RestMethod -Uri $testUri -Headers $headers -Method Get
    Write-Host "Connection OK. Found $($testResp.paging.total) projects." -ForegroundColor Green
} catch {
    Write-Error "Connection/Auth failed: $($_.Exception.Message)"
    exit 1
}

# Function: Rule details
function Get-RuleDetails {
    param($RuleKey)
    $uri = "$ServerUrl/api/rules/show?key=$RuleKey&actives_only=true"
    try {
        $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get
        $rec = ($response.rule.htmlDesc -replace '<[^>]+>','' -replace "`r`n", "`n").Trim()  # Clean HTML + normalize lines
        return @{
            Recommendation = if ($rec) { $rec } else { 'No recommendation available' }
            Effort = if ($response.rule.remedialEffort) { $response.rule.remedialEffort } else { 'Unknown' }
        }
    } catch {
        Write-Warning "Rule fetch failed for $RuleKey : $($_.Exception.Message)"
        return @{ Recommendation = 'Error fetching recommendation'; Effort = 'Unknown' }
    }
}

# Function: Code snippet (UTF-8 aware)
function Get-CodeSnippet {
    param($ComponentKey, $LineNumber)
    if (-not $LineNumber) { return 'File-level issue (no line specified)' }
    $uri = "$ServerUrl/api/sources/raw?key=$ComponentKey"
    try {
        $sourceBytes = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get -Raw
        $source = [System.Text.Encoding]::UTF8.GetString($sourceBytes)
        $lines = $source -split "`n" | Where-Object { $_ -ne '' }  # Trim empty
        if ($lines.Count -eq 0) { return 'Empty source file' }
        $startLine = [Math]::Max(1, $LineNumber - $SnippetLinesBefore)
        $endLine = [Math]::Min($lines.Count, $LineNumber + $SnippetLinesAfter)
        $snippetLines = @()
        for ($i = $startLine - 1; $i -lt $endLine; $i++) {
            $snippetLines += "Line $($i + 1): $($lines[$i])"
        }
        return $snippetLines -join "`n"
    } catch {
        Write-Warning "Snippet fetch failed for $ComponentKey (Line $LineNumber): $($_.Exception.Message)"
        return "Error: Unable to retrieve source (check if file exists/deleted)"
    }
}

# Fetch issues with pagination
$allIssues = @()
$page = 1
$resolvedParam = if ($IncludeResolved) { '' } else { '&resolved=false' }
$uriBase = "$ServerUrl/api/issues/search?componentKeys=$ProjectKey&ps=$PageSize$resolvedParam"

do {
    $uri = "$uriBase&p=$page"
    Write-Host "Fetching page $page ..." -ForegroundColor Yellow
    try {
        $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get
        $issues = $response.issues
        $allIssues += $issues
        Write-Host "Page $page : $($issues.Count) issues (Total so far: $($allIssues.Count))" -ForegroundColor Cyan
        if ($response.paging.total -eq 0) { Write-Warning "No issues foundâ€”check project key or add -IncludeResolved" }
        $page++
    } catch {
        Write-Error "Page fetch failed: $($_.Exception.Message)"
        break
    }
} while ($allIssues.Count -lt $response.paging.total -and $issues.Count -gt 0)

if ($allIssues.Count -eq 0) {
    Write-Warning "No issues exported. Verify: ProjectKey='$ProjectKey', token perms, unresolved issues exist?"
    exit 0
}

# Process
Write-Host "Processing $($allIssues.Count) issues..." -ForegroundColor Green
$exportData = @()
$counter = 0
foreach ($issue in $allIssues) {
    $counter++
    Write-Progress -Activity "Processing Issues" -Status "$counter/$($allIssues.Count)" -PercentComplete (($counter / $allIssues.Count) * 100)
    
    $ruleDetails = Get-RuleDetails -RuleKey $issue.rule
    $snippet = Get-CodeSnippet -ComponentKey $issue.component -LineNumber $issue.line
    
    $exportData += [PSCustomObject]@{
        'Rule ID' = $issue.rule
        'Severity' = $issue.severity
        'Type' = $issue.type
        'Component' = $issue.component -replace "$ProjectKey`:", ''  # Clean path for ABAP files
        'Line' = $issue.line
        'Message' = $issue.message
        'Recommendation' = $ruleDetails.Recommendation.Substring(0, [Math]::Min(500, $ruleDetails.Recommendation.Length)) + '...'  # Trunc for CSV
        'Effort' = $ruleDetails.Effort
        'Code Snippet' = $snippet.Substring(0, [Math]::Min(2000, $snippet.Length)) + '...'  # Trunc long snippets
    }
}

# Export
$exportData | Export-Csv -Path $OutputPath -NoTypeInformation -Encoding UTF8
Write-Host "Exported $($allIssues.Count) issues to $OutputPath" -ForegroundColor Green
Write-Host "Sample row:" -ForegroundColor Gray
$exportData | Select-Object -First 1 | Format-List
