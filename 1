param(
    [Parameter(Mandatory=$true)]
    [string]$ServerUrl,  # e.g., "https://your-sonarqube.com" â€“ NO trailing slash
    
    [Parameter(Mandatory=$true)]
    [string]$Token,
    
    [Parameter(Mandatory=$true)]
    [string]$ProjectKey,
    
    [Parameter(Mandatory=$true)]
    [string]$OutputPath,
    
    [int]$SnippetLinesBefore = 3,
    
    [int]$SnippetLinesAfter = 3,
    
    [int]$PageSize = 500,
    
    [switch]$SkipCertCheck  # For self-signed HTTPS
)

# Headers
$headers = @{
    'Authorization' = "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$Token")))"
}

# RestMethod params for SSL/proxy
$restParams = @{
    Headers = $headers
    Method = 'Get'
}
if ($SkipCertCheck) { $restParams['SkipCertificateCheck'] = $true }

Write-Host "Starting export for $ProjectKey..." -ForegroundColor Green

# Auth test (inline)
Write-Host "Validating auth..." -ForegroundColor Yellow
try {
    $authUri = "$ServerUrl/api/authentication/validate"
    Invoke-RestMethod -Uri $authUri @restParams | Out-Null
    Write-Host "Auth OK." -ForegroundColor Green
} catch {
    Write-Error "Auth error: $($_.Exception.Message). Check token/URL."
    exit 1
}

# Fetch rule details
function Get-RuleDetails {
    param($RuleKey)
    Write-Host "Fetching rule: $RuleKey" -ForegroundColor Cyan
    $uri = "$ServerUrl/api/rules/show?key=${RuleKey}&actives=true"
    try {
        $response = Invoke-RestMethod -Uri $uri @restParams
        $rec = if ($response.rule.htmlDesc) { $response.rule.htmlDesc -replace '<[^>]+>','' -replace "`r`n", ' ' } else { 'N/A' }
        return @{
            Recommendation = $rec.Substring(0, [Math]::Min(500, $rec.Length))  # Trunc for CSV
            Effort = if ($response.rule.effort) { $response.rule.effort } else { 'Unknown' }
        }
    } catch {
        Write-Warning "Rule fetch failed: $RuleKey - $($_.Exception.Message)"
        return @{ Recommendation = 'No recommendation'; Effort = 'Unknown' }
    }
}

# Get code snippet
function Get-CodeSnippet {
    param($ComponentKey, $LineNumber)
    Write-Host "Fetching snippet: $ComponentKey (line $LineNumber)" -ForegroundColor Cyan
    $uri = "$ServerUrl/api/sources/raw?key=${ComponentKey}"
    try {
        $source = Invoke-RestMethod -Uri $uri @restParams
        if (-not $source) { return 'Empty source file' }
        $lines = $source -split "`n" | Where-Object { $_ }
        if ($lines.Count -eq 0) { return 'No lines in file' }
        $start = [Math]::Max(1, $LineNumber - $SnippetLinesBefore)
        $end = [Math]::Min($lines.Count, $LineNumber + $SnippetLinesAfter)
        $snippetLines = @()
        for ($i = $start; $i -le $end; $i++) {
            $snippetLines += "L$i`: $($lines[$i-1])"
        }
        return ($snippetLines -join "`n").Substring(0, [Math]::Min(2000, $snippetLines.Count * 100))  # Cap for CSV
    } catch {
        Write-Warning "Snippet failed: $ComponentKey - $($_.Exception.Message)"
        return "Fetch error: $($_.Exception.Message.Split(':')[0])"
    }
}

# Paginate issues
$allIssues = @()
$page = 1
do {
    $uri = "$ServerUrl/api/issues/search?componentKeys=$([Uri]::EscapeDataString($ProjectKey))&ps=$PageSize&p=$page"
    Write-Host "Fetching page $page (URI: $uri)" -ForegroundColor Yellow
    try {
        $response = Invoke-RestMethod -Uri $uri @restParams
        $issues = $response.issues
        $allIssues += $issues
        Write-Host "Page $page: $($issues.Count) issues. Total so far: $($allIssues.Count)/$($response.total)" -ForegroundColor Green
        if ($issues.Count -eq 0) { break }
        Start-Sleep -Milliseconds 100  # Throttle if needed
        $page++
    } catch {
        Write-Error "Pagination error page $page`: $($_.Exception.Message)"
        break
    }
} while ($allIssues.Count -lt $response.total -and $page -le 20)  # Safety cap

if ($allIssues.Count -eq 0) {
    Write-Warning "No issues found. Check project key/permissions."
    exit 1
}

# Process
$exportData = @()
$counter = 0
foreach ($issue in $allIssues) {
    $counter++
    Write-Host "Processing $counter/$($allIssues.Count): $($issue.rule)" -ForegroundColor Cyan
    $ruleDetails = Get-RuleDetails -RuleKey $issue.rule
    $snippet = if ($issue.line) { 
        Get-CodeSnippet -ComponentKey $issue.component -LineNumber $issue.line 
    } else { 
        'File-level issue (no line)' 
    }
    
    $exportData += [PSCustomObject]@{
        'Rule ID' = $issue.rule
        'Severity' = $issue.severity
        'Type' = $issue.type
        'Component' = $issue.component -replace '^[^:]+:', ''  # Clean ABAP path
        'Line' = if ($issue.line) { $issue.line } else { 'N/A' }
        'Message' = $issue.message
        'Recommendation' = $ruleDetails.Recommendation
        'Effort' = $ruleDetails.Effort
        'Code Snippet' = $snippet
    }
}

# Export
$exportData | Export-Csv -Path $OutputPath -NoTypeInformation -Encoding UTF8
$exportData | ConvertTo-Json -Depth 3 | Out-File "$OutputPath.json"  # Fallback for snippets
Write-Host "Exported $($allIssues.Count) issues to $OutputPath (CSV) and $OutputPath.json" -ForegroundColor Green
