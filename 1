<#
.SYNOPSIS
  Export SonarQube Security issues (VULNERABILITY) with file, line, and a code snippet.

.PARAMETER BaseUrl
  SonarQube base URL, e.g. https://sonar.mycompany.com

.PARAMETER Token
  Personal token (My Account -> Security). Use as Bearer.

.PARAMETER ProjectKey
  SonarQube project key (exact key, not display name).

.PARAMETER Branch
  Optional branch name (omit or set "" if not using branches).

.PARAMETER Languages
  Optional comma-separated language filter, e.g. "abap,xml"

.PARAMETER Context
  Number of context lines around the issue line (default 2 → 5-line window).

.PARAMETER OutCsv
  Output CSV file path.
#>

param(
  [Parameter(Mandatory=$true)] [string]$BaseUrl,
  [Parameter(Mandatory=$true)] [string]$Token,
  [Parameter(Mandatory=$true)] [string]$ProjectKey,
  [string]$Branch = "main",
  [string]$Languages = "",
  [int]$Context = 2,
  [string]$OutCsv = "security_issues_with_snippets.csv"
)

$ErrorActionPreference = "Stop"
$ProgressPreference = "SilentlyContinue"

# Ensure TLS 1.2+ on older Windows PowerShell
if ([System.Net.ServicePointManager]::SecurityProtocol -band [System.Net.SecurityProtocolType]::Tls12 -eq 0) {
  [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12
}

# --- Auth header (Bearer). If your server needs Basic, see comment below. ---
$Headers = @{ Authorization = "Bearer $Token" }

function Invoke-SQGet {
  param(
    [Parameter(Mandatory=$true)] [string]$Path,
    [hashtable]$Query = @{}
  )
  $uriBuilder = [System.UriBuilder]("$BaseUrl$Path")
  # Append query parameters
  if ($Query -and $Query.Count -gt 0) {
    $nv = [System.Web.HttpUtility]::ParseQueryString([string]::Empty)
    foreach ($k in $Query.Keys) { if ($null -ne $Query[$k] -and $Query[$k] -ne "") { $nv[$k] = [string]$Query[$k] } }
    $uriBuilder.Query = $nv.ToString()
  }
  return Invoke-RestMethod -Method Get -Uri $uriBuilder.Uri -Headers $Headers
}

function Get-SQIssues {
  [CmdletBinding()]
  param()
  $page = 1
  $pageSize = 500
  $baseParams = @{
    componentKeys    = $ProjectKey
    types            = "VULNERABILITY"
    ps               = $pageSize
    additionalFields = "_all"
  }
  if ($Branch)    { $baseParams.branch    = $Branch }
  if ($Languages) { $baseParams.languages = $Languages }

  while ($true) {
    $params = $baseParams.Clone()
    $params.p = $page
    $resp = Invoke-SQGet -Path "/api/issues/search" -Query $params
    foreach ($it in ($resp.issues | ForEach-Object { $_ })) { $it }
    $total = [int]$resp.paging.total
    if ($page * $pageSize -ge $total) { break }
    $page++
  }
}

# Cache file texts per component to avoid repeated calls
$FileCache = @{}

function Get-FileLines {
  param([Parameter(Mandatory=$true)][string]$ComponentKey)
  if ($FileCache.ContainsKey($ComponentKey)) { return $FileCache[$ComponentKey] }

  $q = @{ key = $ComponentKey }
  if ($Branch) { $q.branch = $Branch }
  try {
    $raw = Invoke-SQGet -Path "/api/sources/raw" -Query $q
    # Split on CRLF/LF into an array (1-based in our rendering)
    $lines = ($raw -split "`r?`n")
  } catch {
    $lines = @()  # no access or binary (or file-level only)
  }
  $FileCache[$ComponentKey] = $lines
  return $lines
}

$results = New-Object System.Collections.Generic.List[object]

Write-Host "Fetching security issues (type=VULNERABILITY) for '$ProjectKey'..." -ForegroundColor Cyan
$issues = Get-SQIssues

$idx = 0
foreach ($i in $issues) {
  $idx++
  if ($idx % 50 -eq 0) { Write-Host ("Processed {0}/{1}..." -f $idx, ($issues.Count)) }

  $component = $i.component
  $line = $i.textRange.startLine
  $snippet = ""
  $lines = @()

  if ($line -and $component) {
    $lines = Get-FileLines -ComponentKey $component
    if ($lines.Count -gt 0) {
      $lo = [Math]::Max(1, $line - $Context)
      $hi = [Math]::Min($lines.Count, $line + $Context)
      $window = for ($ln = $lo; $ln -le $hi; $ln++) {
        $mark = if ($ln -eq $line) { ">>" } else { "  " }
        "{0} {1,5}: {2}" -f $mark, $ln, $lines[$ln-1]
      }
      $snippet = ($window -join "`n")
    }
  }

  $obj = [pscustomobject]@{
    IssueKey   = $i.key
    Type       = $i.type
    Severity   = $i.severity
    Status     = $i.status
    Rule       = $i.rule
    Language   = $i.language
    File       = $component
    Line       = if ($line) { $line } else { "" }
    Message    = ($i.message -replace "`r?`n"," ").Trim()
    Snippet    = $snippet
  }
  $results.Add($obj) | Out-Null
}

# If no issues, still create an empty CSV with headers
if ($results.Count -eq 0) {
  $results = ,([pscustomobject]@{
    IssueKey=""; Type=""; Severity=""; Status=""; Rule=""
    Language=""; File=""; Line=""; Message=""; Snippet=""
  }) | Select-Object * | Select-Object -First 0
}

$results | Export-Csv -Path $OutCsv -NoTypeInformation -Encoding UTF8
Write-Host "Done. Wrote $($results.Count) rows to '$OutCsv'." -ForegroundColor Green

# --- OPTIONAL: Basic auth fallback (use instead of Bearer if needed) ---
# $basic = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("$Token:"))
# $Headers = @{ Authorization = "Basic $basic" }

