param(
    [Parameter(Mandatory=$true)]
    [string]$ServerUrl,
    
    [Parameter(Mandatory=$true)]
    [string]$Token,
    
    [Parameter(Mandatory=$true)]
    [string]$ProjectKey,
    
    [Parameter(Mandatory=$true)]
    [string]$OutputPath,
    
    [int]$SnippetLinesBefore = 3,
    
    [int]$SnippetLinesAfter = 3,
    
    [int]$PageSize = 500
)

# Headers for API auth
$headers = @{
    'Authorization' = "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$Token")))"
}

# Function to fetch rule details (recommendation)
function Get-RuleDetails {
    param($RuleKey)
    $uri = "$ServerUrl/api/rules/show?key=$RuleKey&actives=true"
    try {
        $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get
        return @{
            Recommendation = $response.rule.htmlDesc -replace '<[^>]+>',''  # Strip HTML for clean text
            Effort = if ($response.rule.remedialEffort) { $response.rule.remedialEffort } else { 'Unknown' }
        }
    } catch {
        return @{ Recommendation = 'No recommendation available'; Effort = 'Unknown' }
    }
}

# Function to get code snippet from source
function Get-CodeSnippet {
    param($ComponentKey, $LineNumber)
    $uri = "$ServerUrl/api/sources/raw?key=$ComponentKey"
    try {
        $source = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get
        $lines = $source -split "`n"
        $startLine = [Math]::Max(1, $LineNumber - $SnippetLinesBefore)
        $endLine = [Math]::Min($lines.Count, $LineNumber + $SnippetLinesAfter)
        $snippet = ($lines[$startLine-1..($endLine-1)] | ForEach-Object { "Line $($_.Index + $startLine): $_" }) -join "`n"
        return $snippet
    } catch {
        return "Error fetching source for $ComponentKey (Line $LineNumber)"
    }
}

# Collect all issues (handle pagination)
$allIssues = @()
$page = 1
$total = 0

do {
    $uri = "$ServerUrl/api/issues/search?componentKeys=$ProjectKey&ps=$PageSize&p=$page"
    $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get
    $issues = $response.issues
    $allIssues += $issues
    $total = $response.total
    $page++
} while (($allIssues.Count -lt $total) -and ($issues.Count -gt 0))

# Process issues
$exportData = @()
foreach ($issue in $allIssues) {
    $ruleDetails = Get-RuleDetails -RuleKey $issue.rule
    $snippet = if ($issue.line) { Get-CodeSnippet -ComponentKey $issue.component -LineNumber $issue.line } else { 'No specific line (e.g., file-level issue)' }
    
    $exportData += [PSCustomObject]@{
        'Rule ID' = $issue.rule
        'Severity' = $issue.severity
        'Type' = $issue.type
        'Component' = $issue.component
        'Line' = $issue.line
        'Message' = $issue.message
        'Recommendation' = $ruleDetails.Recommendation
        'Effort' = $ruleDetails.Effort
        'Code Snippet' = $snippet
    }
}

# Export to CSV
$exportData | Export-Csv -Path $OutputPath -NoTypeInformation -Encoding UTF8
Write-Host "Exported $($allIssues.Count) issues to $OutputPath"
