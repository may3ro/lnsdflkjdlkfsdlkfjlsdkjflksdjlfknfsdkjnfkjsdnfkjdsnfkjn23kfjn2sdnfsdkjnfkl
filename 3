# ===========================================
# SonarQube ABAP Security Export (PS 7.5.4)
# Project: abap-all-test3  |  Issues + Snippets
# ===========================================

# -------- CONFIG --------
$Base        = 'http://localhost:9000'          # your SonarQube base URL (no trailing /)
$UserToken   = '<YOUR_USER_TOKEN>'              # user token with Browse + See Source Code
$ProjectKey  = 'abap-all-test3'                 # real project key
$Branch      = ''                               # e.g. 'main' or '' if not used
$PullRequest = ''                               # e.g. '123' or '' if not used
$OutCsv      = 'SQ_Vulnerabilities_abap-all-test3.csv'

# -------- AUTH HEADER (safe) --------
$pair  = $UserToken + ':'                       # no "$Var:" interpolation
$basic = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($pair))
$H     = @{ Authorization = "Basic $basic" }

# -------- SANITY CHECKS --------
$ver = Invoke-RestMethod -Uri "$Base/api/server/version" -Headers $H -ErrorAction Stop
Write-Host "SonarQube server version: $ver"

# Prove issues endpoint works without filter
$null = Invoke-RestMethod -Uri "$Base/api/issues/search?p=1&ps=1" -Headers $H -ErrorAction Stop

# -------- PICK THE RIGHT PROJECT FILTER PARAM --------
$IssuesEndpoint = "$Base/api/issues/search"
$workingParam = $null

# try 'projects' first (most common on 2025.x), then 'components'
foreach ($p in @('projects','components')) {
    $u = "$IssuesEndpoint?${p}=$([uri]::EscapeDataString($ProjectKey))&types=VULNERABILITY&p=1&ps=1"
    if ($Branch)      { $u += "&branch=$([uri]::EscapeDataString($Branch))" }
    if ($PullRequest) { $u += "&pullRequest=$([uri]::EscapeDataString($PullRequest))" }
    try {
        $r = Invoke-RestMethod -Uri $u -Headers $H -Method Get -ErrorAction Stop
        if ($r -and $r.paging) { $workingParam = $p; break }
    } catch { }
}
if (-not $workingParam) {
    throw "Could not call /api/issues/search for project '$ProjectKey'. Open $Base/web_api â†’ issues/search and check the exact param (projects/components)."
}
Write-Host "Using /api/issues/search with parameter '$workingParam'."

# -------- HELPERS --------
function Strip-Html([string]$s) {
    if (-not $s) { return '' }
    (($s -replace '<[^>]+>', '') -replace '\s+', ' ').Trim()
}

function Get-AllVulnerabilities {
    $all=@(); $page=1; $ps=500
    do {
        $u = "$IssuesEndpoint?${workingParam}=$([uri]::EscapeDataString($ProjectKey))&types=VULNERABILITY&p=$page&ps=$ps"
        if ($Branch)      { $u += "&branch=$([uri]::EscapeDataString($Branch))" }
        if ($PullRequest) { $u += "&pullRequest=$([uri]::EscapeDataString($PullRequest))" }
        $resp = Invoke-RestMethod -Uri $u -Headers $H -Method Get -ErrorAction Stop
        if ($resp.issues) { $all += $resp.issues }
        $total = [int]$resp.paging.total
        $page++
    } while ($all.Count -lt $total)
    $all
}

function Get-Rule([string]$RuleKey) {
    try {
        $r = Invoke-RestMethod -Uri ("$Base/api/rules/show?key=$([uri]::EscapeDataString($RuleKey))") -Headers $H -Method Get -ErrorAction Stop
        if ($r -and $r.rule) { return $r.rule } else { return $null }
    } catch { return $null }
}

function Get-SourceLines([string]$ComponentKey) {
    # Try RAW first
    $u = "$Base/api/sources/raw?key=$([uri]::EscapeDataString($ComponentKey))"
    if ($Branch)      { $u += "&branch=$([uri]::EscapeDataString($Branch))" }
    if ($PullRequest) { $u += "&pullRequest=$([uri]::EscapeDataString($PullRequest))" }
    try {
        $raw = Invoke-RestMethod -Uri $u -Headers $H -Method Get -ErrorAction Stop
        if ($raw) { return ($raw -split "`n") }
    } catch { }

    # Fallback: SHOW (JSON)
    $u2 = "$Base/api/sources/show?key=$([uri]::EscapeDataString($ComponentKey))"
    if ($Branch)      { $u2 += "&branch=$([uri]::EscapeDataString($Branch))" }
    if ($PullRequest) { $u2 += "&pullRequest=$([uri]::EscapeDataString($PullRequest))" }
    try {
        $show = Invoke-RestMethod -Uri $u2 -Headers $H -Method Get -ErrorAction Stop
        if ($show -and $show.sources) { return @($show.sources | ForEach-Object { $_.code }) }
    } catch { }
    return $null
}

function Get-Snippet([string]$ComponentKey, [int]$Line) {
    if (-not $Line -or $Line -le 0) { return '' }
    $lines = Get-SourceLines $ComponentKey
    if (-not $lines) { return '' }
    $start = [Math]::Max(1, $Line - 3)
    $end   = [Math]::Min($lines.Length, $Line + 3)
    ($start..$end | ForEach-Object { '{0,4}: {1}' -f $_, $lines[$_-1] }) -join "`n"
}

# -------- FETCH + ENRICH + EXPORT --------
$issues = Get-AllVulnerabilities
Write-Host ("Vulnerabilities returned: {0}" -f $issues.Count)

$rows = foreach ($i in $issues) {
    # line can be in .line or .textRange.startLine
    $line = if ($i.line) { [int]$i.line } elseif ($i.textRange -and $i.textRange.startLine) { [int]$i.textRange.startLine } else { $null }

    $rule = Get-Rule $i.rule
    $ruleName = if ($rule -and $rule.name) { $rule.name } else { $i.rule }
    $descHtml = if ($rule -and $rule.htmlDesc) { $rule.htmlDesc } elseif ($rule -and $rule.mdDesc) { $rule.mdDesc } else { '' }
    $desc     = Strip-Html $descHtml
    $reco     = if ($rule -and $rule.remediation) {
                   Strip-Html ( (($rule.remediation.func) ? $rule.remediation.func : '') + ' ' +
                                (($rule.remediation.gapDescription) ? $rule.remediation.gapDescription : '') )
                } elseif ($rule -and $rule.debtRemFnBaseEffort) {
                   Strip-Html $rule.debtRemFnBaseEffort
                } else {
                   $desc
                }

    [pscustomobject]@{
        Project        = $ProjectKey
        Branch         = ($Branch -ne '' ? $Branch : 'main')
        File           = $i.component
        Line           = $line
        Severity       = $i.severity
        Type           = $i.type
        RuleKey        = $i.rule
        RuleName       = $ruleName
        Message        = $i.message
        Description    = $desc
        Recommendation = $reco
        CodeSnippet    = (Get-Snippet $i.component $line)
    }
}

$rows | Export-Csv -Path $OutCsv -NoTypeInformation -Encoding UTF8
Write-Host "Export complete: $OutCsv"
