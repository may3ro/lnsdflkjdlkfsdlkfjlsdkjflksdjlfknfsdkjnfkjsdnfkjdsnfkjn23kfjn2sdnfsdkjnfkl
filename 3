# ============================================================
# SonarQube ABAP Security Export (PS 7.5.4)
# Project: abap-all-test3
# Output: Vulnerabilities with Rule text + Â±3-line Snippets
# ============================================================

# ---------------- CONFIG ----------------
$Base        = 'http://localhost:9000'      # SonarQube base URL
$UserToken   = '<YOUR_USER_TOKEN>'          # Must have "Browse" + "See Source Code"
$ProjectKey  = 'abap-all-test3'
$Branch      = ''                           # 'main' or leave blank
$PullRequest = ''                           # leave blank if not PR
$OutCsv      = 'SQ_Vulnerabilities_abap-all-test3.csv'
$BatchSize   = 100
$SortMode    = 'SeverityThenFile'           # or 'FileThenSeverity'

# ---------------- AUTH HEADER ----------------
$pair  = $UserToken + ':'
$basic = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($pair))
$H     = @{ Authorization = "Basic $basic" }

# ---------------- GENERIC HELPERS ----------------
function GET([string]$u) {
  Invoke-RestMethod -Uri $u -Headers $H -Method Get -ErrorAction Stop
}

function Strip-Html([string]$s) {
  if (-not $s) { return '' }
  (($s -replace '<[^>]+>', ' ') -replace '\s+', ' ').Trim()
}

function Get-RuleSection {
    param([string]$htmlOrMd, [string]$sectionTitle)
    if (-not $htmlOrMd) { return '' }

    $pattern = "(?is)<h[12][^>]*>\s*$([regex]::Escape($sectionTitle))\s*</h[12]>\s*(?<body>.+?)(?:<h[12][^>]*>|\z)"
    $m = [regex]::Match($htmlOrMd, $pattern)
    if ($m.Success) { return (Strip-Html $m.Groups['body'].Value) }

    $pattern2 = "(?im)^\s*##\s*$([regex]::Escape($sectionTitle))\s*$\R(?<body>[\s\S]+?)(?=^\s*##\s+|^\s*#\s+|\z)"
    $m2 = [regex]::Match($htmlOrMd, $pattern2)
    if ($m2.Success) { return (($m2.Groups['body'].Value -replace '\s+', ' ').Trim()) }

    return ''
}

function Severity-Rank {
    param([string]$sev)
    switch ($sev.ToUpperInvariant()) {
        'BLOCKER'  { 0 }
        'CRITICAL' { 1 }
        'MAJOR'    { 2 }
        'MINOR'    { 3 }
        'INFO'     { 4 }
        default    { 5 }
    }
}

# ---------------- RULE FETCH (robust) ----------------
function Get-RuleRich([string]$RuleKey) {
  # 1) /rules/show
  try {
    $r = GET ("$Base/api/rules/show?key={0}" -f [uri]::EscapeDataString($RuleKey))
    if ($r -and $r.rule) {
      $rule = $r.rule
      $desc = $rule.htmlDesc ?? $rule.mdDesc ?? $rule.htmlDescription ?? $rule.markdownDescription ?? $rule.description ?? $rule.htmlNote ?? $rule.note
      $rem  = ''
      if ($rule.remediation) {
        $rem = ((($rule.remediation.func) ? $rule.remediation.func : '') + ' ' +
                (($rule.remediation.gapDescription) ? $rule.remediation.gapDescription : ''))
      } elseif ($rule.debtRemFnBaseEffort) {
        $rem = $rule.debtRemFnBaseEffort
      }
      return @{
        Key            = $rule.key
        Name           = ($rule.name ?? $RuleKey)
        HtmlOrMd       = $desc
        RemediationTxt = $rem
      }
    }
  } catch {}

  # 2) /rules/search
  try {
    $s = GET ("$Base/api/rules/search?rule_key={0}" -f [uri]::EscapeDataString($RuleKey))
    if ($s -and $s.rules -and $s.rules.Count -gt 0) {
      $rule = $s.rules[0]
      $desc = $rule.htmlDesc ?? $rule.mdDesc ?? $rule.htmlDescription ?? $rule.markdownDescription ?? $rule.description ?? $rule.htmlNote ?? $rule.note
      $rem  = ''
      if ($rule.remediation) {
        $rem = ((($rule.remediation.func) ? $rule.remediation.func : '') + ' ' +
                (($rule.remediation.gapDescription) ? $rule.remediation.gapDescription : ''))
      } elseif ($rule.debtRemFnBaseEffort) {
        $rem = $rule.debtRemFnBaseEffort
      }
      return @{
        Key            = $rule.key
        Name           = ($rule.name ?? $RuleKey)
        HtmlOrMd       = $desc
        RemediationTxt = $rem
      }
    }
  } catch {}

  return @{
    Key            = $RuleKey
    Name           = $RuleKey
    HtmlOrMd       = ''
    RemediationTxt = ''
  }
}

# ---------------- SOURCE + SNIPPETS ----------------
function Get-SourceLines([string]$ComponentKey) {
  $u = "$Base/api/sources/raw?key={0}" -f [uri]::EscapeDataString($ComponentKey)
  if ($Branch)      { $u += "&branch={0}"      -f [uri]::EscapeDataString($Branch) }
  if ($PullRequest) { $u += "&pullRequest={0}" -f [uri]::EscapeDataString($PullRequest) }
  try {
    $raw = GET $u
    if ($raw) { return ($raw -split "`n") }
  } catch {}

  $u2 = "$Base/api/sources/show?key={0}" -f [uri]::EscapeDataString($ComponentKey)
  if ($Branch)      { $u2 += "&branch={0}"      -f [uri]::EscapeDataString($Branch) }
  if ($PullRequest) { $u2 += "&pullRequest={0}" -f [uri]::EscapeDataString($PullRequest) }
  try {
    $show = GET $u2
    if ($show -and $show.sources) { return @($show.sources | ForEach-Object { $_.code }) }
  } catch {}
  $null
}

function Snippet([string]$ComponentKey, [int]$Line) {
  if (-not $Line -or $Line -le 0) { return '' }
  $lines = Get-SourceLines $ComponentKey
  if (-not $lines) { return '' }
  $start = [Math]::Max(1, $Line - 3)
  $end   = [Math]::Min($lines.Length, $Line + 3)
  ($start..$end | ForEach-Object { '{0,4}: {1}' -f $_, $lines[$_-1] }) -join "`n"
}

function Join-Encoded([string[]]$arr) {
  if (-not $arr -or $arr.Count -eq 0) { return '' }
  ($arr | ForEach-Object { [uri]::EscapeDataString($_) }) -join ','
}

# ---------------- FETCH COMPONENTS ----------------
$ver = GET "$Base/api/server/version"
Write-Host "SonarQube version: $ver"

Write-Host "Collecting file components for project '$ProjectKey'..."
$files=@(); $p=1; $ps=500
do {
  $u = "$Base/api/components/tree?component={0}&qualifiers=FIL&p={1}&ps={2}" -f [uri]::EscapeDataString($ProjectKey),$p,$ps
  if ($Branch)      { $u += "&branch={0}"      -f [uri]::EscapeDataString($Branch) }
  if ($PullRequest) { $u += "&pullRequest={0}" -f [uri]::EscapeDataString($PullRequest) }
  $r = GET $u
  if ($r.components) { $files += $r.components }
  $p++
} while ($r.components -and $r.components.Count -eq $ps)

if ($files.Count -eq 0) { throw "No file components found under project '$ProjectKey'." }
Write-Host ("Files discovered: {0}" -f $files.Count)

# ---------------- FETCH ISSUES ----------------
Write-Host "Fetching vulnerabilities (types=VULNERABILITY)..."
$issues=@()
for ($i=0; $i -lt $files.Count; $i+=$BatchSize) {
  $slice=$files[$i..([Math]::Min($i+$BatchSize-1,$files.Count-1))]
  $keysEnc = Join-Encoded ($slice | ForEach-Object { $_.key })
  $baseUrl="$Base/api/issues/search?componentKeys=$keysEnc&types=VULNERABILITY&ps=500"
  if ($Branch)      { $baseUrl+="&branch={0}"      -f [uri]::EscapeDataString($Branch) }
  if ($PullRequest) { $baseUrl+="&pullRequest={0}" -f [uri]::EscapeDataString($PullRequest) }

  $page=1
  do {
    $r=GET ($baseUrl+"&p=$page")
    if ($r.issues) { $issues+=$r.issues }
    $total=[int]$r.paging.total
    $pages=[math]::Ceiling($total/500)
    $page++
  } while ($page -le $pages)
}
Write-Host ("Vulnerabilities collected: {0}" -f $issues.Count)

# ---------------- ENRICHMENT ----------------
Write-Host "Enriching rules and snippets..."
$rows=foreach($i in $issues){
  $line=$null
  if($i.line){$line=[int]$i.line}elseif($i.textRange -and $i.textRange.startLine){$line=[int]$i.textRange.startLine}

  $ruleRich=Get-RuleRich $i.rule
  $ruleName=$ruleRich.Name
  $descHtmlOrMd=$ruleRich.HtmlOrMd

  $why=''; $how=''

  if($descHtmlOrMd){
    $why = Get-RuleSection -htmlOrMd $descHtmlOrMd -sectionTitle 'Why is this an issue?'
    if(-not $why){$why = Get-RuleSection -htmlOrMd $descHtmlOrMd -sectionTitle 'Why is this an Issue?'}
    if(-not $why){$why = Get-RuleSection -htmlOrMd $descHtmlOrMd -sectionTitle 'Why is this a problem?'}
    $how = Get-RuleSection -htmlOrMd $descHtmlOrMd -sectionTitle 'How to fix it'
    if(-not $how){$how = Get-RuleSection -htmlOrMd $descHtmlOrMd -sectionTitle 'Recommended resolution'}
    if(-not $how){$how = Get-RuleSection -htmlOrMd $descHtmlOrMd -sectionTitle 'Compliant solution'}
  }

  $descPlain = if($descHtmlOrMd){Strip-Html $descHtmlOrMd}else{''}
  $recoTxt   = if($ruleRich.RemediationTxt){Strip-Html $ruleRich.RemediationTxt}else{''}

  if(-not $why){$why=$descPlain}
  if(-not $how){$how=$recoTxt}
  if(-not $recoTxt){$recoTxt=$how}

  [pscustomobject]@{
    Project        = $ProjectKey
    Branch         = ($Branch -ne '' ? $Branch : 'main')
    File           = $i.component
    Line           = $line
    Severity       = $i.severity
    Type           = $i.type
    RuleKey        = $i.rule
    RuleName       = $ruleName
    Message        = $i.message
    WhyIssue       = $why
    Description    = $descPlain
    HowToFix       = $how
    Recommendation = $recoTxt
    CodeSnippet    = (Snippet $i.component $line)
  }
}

# Warn if any rules returned no descriptive text
$noDesc = $rows | Where-Object { -not $_.Description -and -not $_.WhyIssue -and -not $_.HowToFix -and -not $_.Recommendation } |
           Select-Object -ExpandProperty RuleKey -Unique
if($noDesc){ Write-Warning ("Rules with no description returned by API: {0}" -f ($noDesc -join ', ')) }

# ---------------- SORT + EXPORT ----------------
if($SortMode -eq 'SeverityThenFile'){
  $rows=$rows|Sort-Object @{e={Severity-Rank $_.Severity}},@{e='File'},@{e='Line'}
}else{
  $rows=$rows|Sort-Object @{e='File'},@{e='Line'},@{e={Severity-Rank $_.Severity}}
}

$rows|Export-Csv -Path $OutCsv -NoTypeInformation -Encoding UTF8
Write-Host "Export complete: $OutCsv"
