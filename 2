# ===============================================
# SonarQube ABAP Security Export (PS 7.5.4 / SQ 2025.x)
# - Issues + rule text + code snippets (Â±3 lines)
# - Branch / PR aware
# - Parallel fetch for rules & sources
# ===============================================

# ------------ CONFIG ------------
$SonarQubeUrl = "http://localhost:9000"
$UserToken    = "YOUR_USER_TOKEN_WITH_SOURCE_ACCESS"
$ProjectKey   = "your_project_key"
$Branch       = ""          # e.g. "develop" or "" for main
$PullRequest  = ""          # e.g. "123" or "" if not PR
$OutputCsv    = "SonarQube_ABAP_Security_Report.csv"
$Throttle     = 8           # parallelism for rule/source fetch (tune to your server)
$UseShowOnly  = $false      # set $true if /api/sources/raw is blocked by policy
# ---- Put these at the top (after token/headers) ----
function Test-200($url) {
    try {
        $r = Invoke-RestMethod -Uri $url -Headers $Headers -Method Get -ErrorAction Stop
        return $r
    } catch {
        return $null
    }
}

function Resolve-SQ {
    param([string]$Base)  # e.g. "http://localhost:9000"

    # 1) resolve context path
    $candidates = @(
        $Base.TrimEnd('/'),
        ($Base.TrimEnd('/') + "/sonarqube"),
        ($Base.TrimEnd('/') + "/sonar")
    )
    $resolvedBase = $null
    foreach ($b in $candidates) {
        if (Test-200 ($b + "/api/server/version")) { $resolvedBase = $b; break }
    }
    if (-not $resolvedBase) { throw "Cannot reach SonarQube at $Base (server/version 404)." }

    # 2) resolve issues endpoint + param name
    $endpoints = @("/api/issues/search","/api/issues/v2/search")
    $paramNames = @("projectKeys","projects","componentKeys")

    $issuesUrl = $null
    $paramName = $null
    foreach ($ep in $endpoints) {
        foreach ($pn in $paramNames) {
            $probe = "$resolvedBase$ep?$pn=_probe_&p=1&ps=1"
            $r = Test-200 $probe
            if ($r -and $r.paging) { $issuesUrl = "$resolvedBase$ep"; $paramName = $pn; break }
        }
        if ($issuesUrl) { break }
    }
    if (-not $issuesUrl) {
        throw "Cannot resolve /api/issues endpoint (search and search v2 both 404). Check /web_api in your instance."
    }

    # return an object with helpers
    [pscustomobject]@{
        BaseUrl     = $resolvedBase
        IssuesUrl   = $issuesUrl
        ParamName   = $paramName
        BuildIssues = {
            param($projectKey, $page, $pageSize, $branch, $pr)
            $qs = @{}
            $qs[$paramName] = $projectKey
            $qs["p"]  = $page
            $qs["ps"] = $pageSize
            if ($branch) { $qs["branch"] = $branch }
            if ($pr)     { $qs["pullRequest"] = $pr }
            # join
            $pairs = $qs.GetEnumerator() | ForEach-Object {
                "{0}={1}" -f [uri]::EscapeDataString($_.Key), [uri]::EscapeDataString([string]$_.Value)
            }
            "$issuesUrl?{0}" -f ($pairs -join "&")
        }
    }
}
# Optional: skip TLS checks (self-signed lab)
$Global:SkipTLS = $false    # set true if you have a self-signed cert

# ------------ AUTH & HTTP ------------
$pair         = "$UserToken:"
$encodedToken = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($pair))
$Headers      = @{ Authorization = "Basic $encodedToken" }

function Add-QS([string]$url, [hashtable]$kv) {
    $pairs = foreach ($k in $kv.Keys) {
        if ($null -ne $kv[$k] -and $kv[$k] -ne "") {
            "{0}={1}" -f [uri]::EscapeDataString($k), [uri]::EscapeDataString([string]$kv[$k])
        }
    }
    if (-not $pairs -or $pairs.Count -eq 0) { return $url }
    if ($url -like "*?*") { "$url&$($pairs -join '&')" } else { "$url?$($pairs -join '&')" }
}

function GET([string]$url, [switch]$Quiet) {
    try {
        if ($Global:SkipTLS) { return Invoke-RestMethod -Uri $url -Headers $Headers -Method Get -SkipCertificateCheck -ErrorAction Stop }
        else                 { return Invoke-RestMethod -Uri $url -Headers $Headers -Method Get -ErrorAction Stop }
    } catch {
        if (-not $Quiet) {
            $msg = $_.Exception.Message
            Write-Warning "HTTP GET failed: $url -> $msg"
        }
        $null
    }
}

# ------------ CORE CALLS ------------
function Get-ServerVersion {
    GET "$SonarQubeUrl/api/server/version" -Quiet
}

function Get-Issues([string]$ProjectKey) {
    $all  = @()
    $page = 1
    $ps   = 500
    do {
        $base = "$SonarQubeUrl/api/issues/search"
        $qs = @{ componentKeys = $ProjectKey; p = $page; ps = $ps }
        if ($Branch)      { $qs.branch = $Branch }
        if ($PullRequest) { $qs.pullRequest = $PullRequest }
        $resp = GET (Add-QS $base $qs)
        if (-not $resp) { break }
        if ($resp.issues) { $all += $resp.issues }
        $total = [int]$resp.paging.total
        $page++
    } while ($all.Count -lt $total)
    $all
}

function Get-Rule([string]$RuleKey) {
    $r = GET (Add-QS "$SonarQubeUrl/api/rules/show" @{ key = $RuleKey }) -Quiet
    if ($r -and $r.rule) { $r.rule } else { $null }
}

function Get-SourceLines([string]$ComponentKey) {
    # Try /raw (fast) unless policy says to use /show
    if (-not $UseShowOnly) {
        $raw = GET (Add-QS "$SonarQubeUrl/api/sources/raw" @{ key = $ComponentKey; branch = $Branch; pullRequest = $PullRequest }) -Quiet
        if ($raw) { return ($raw -split "`n") }
    }
    # Fallback to /show
    $show = GET (Add-QS "$SonarQubeUrl/api/sources/show" @{ key = $ComponentKey; branch = $Branch; pullRequest = $PullRequest }) -Quiet
    if ($show -and $show.sources) { return @($show.sources | ForEach-Object { $_.code }) }
    $null
}

function Get-Snippet([string]$ComponentKey, [int]$Line) {
    if (-not $Line -or $Line -le 0) { return "" }
    $lines = Get-SourceLines $ComponentKey
    if (-not $lines) { return "" }
    $start = [Math]::Max(1, $Line - 3)
    $end   = [Math]::Min($lines.Length, $Line + 3)
    ($start..$end | ForEach-Object { "{0,4}: {1}" -f $_, $lines[$_-1] }) -join "`n"
}

function Strip-Html([string]$s) {
    if (-not $s) { return "" }
    (($s -replace '<[^>]+>', '') -replace '\s+', ' ').Trim()
}

# ------------ MAIN ------------
$sv = Get-ServerVersion
Write-Host "SonarQube server version: $sv"

$val = GET "$SonarQubeUrl/api/authentication/validate"
if (-not $val -or -not $val.valid) { throw "Authentication failed. Check token and permissions (Browse + See Source Code)." }

$ctx = @()
if ($Branch)      { $ctx += "branch=$Branch" }
if ($PullRequest) { $ctx += "PR=$PullRequest" }
Write-Host ("Collecting issues for '{0}'{1} ..." -f $ProjectKey, ($ctx.Count ? " (" + ($ctx -join ", ") + ")" : ""))

$issues = Get-Issues $ProjectKey
if (-not $issues -or $issues.Count -eq 0) {
    Write-Host "No issues found for the specified context."
    return
}

# Prepare concurrent work items (one per issue)
# We fetch rule + snippet in parallel to speed up large projects
$work = $issues | ForEach-Object {
    # normalize line (some versions use textRange.startLine)
    $line = if ($_.line) { [int]$_.line } elseif ($_.textRange -and $_.textRange.startLine) { [int]$_.textRange.startLine } else { $null }
    [pscustomobject]@{
        Issue       = $_
        Line        = $line
        Component   = $_.component
        RuleKey     = $_.rule
    }
}

$results = $work | ForEach-Object -Parallel {
    using module Microsoft.PowerShell.Utility

    # local helpers redefined inside parallel runspace
    function Strip-Html([string]$s) {
        if (-not $s) { return "" }
        (($s -replace '<[^>]+>', '') -replace '\s+', ' ').Trim()
    }

    # pull rule
    $ruleResp = Invoke-RestMethod -Uri (("{0}/api/rules/show?key={1}" -f $using:SonarQubeUrl, [uri]::EscapeDataString($PSItem.RuleKey))) `
                                  -Headers $using:Headers -Method Get `
                                  @(@{SkipCertificateCheck=$true}[$using:Global:SkipTLS])

    $rule = if ($ruleResp -and $ruleResp.rule) { $ruleResp.rule } else { $null }

    # pull snippet
    $snippet = ""
    if ($PSItem.Line) {
        # try raw first
        $rawUrl = "{0}/api/sources/raw?key={1}" -f $using:SonarQubeUrl, [uri]::EscapeDataString($PSItem.Component)
        if ($using:Branch)      { $rawUrl += "&branch=$([uri]::EscapeDataString($using:Branch))" }
        if ($using:PullRequest) { $rawUrl += "&pullRequest=$([uri]::EscapeDataString($using:PullRequest))" }

        $lines = $null
        if (-not $using:UseShowOnly) {
            try {
                $raw = Invoke-RestMethod -Uri $rawUrl -Headers $using:Headers -Method Get @(@{SkipCertificateCheck=$true}[$using:Global:SkipTLS])
                if ($raw) { $lines = $raw -split "`n" }
            } catch { }
        }
        if (-not $lines) {
            $showUrl = "{0}/api/sources/show?key={1}" -f $using:SonarQubeUrl, [uri]::EscapeDataString($PSItem.Component)
            if ($using:Branch)      { $showUrl += "&branch=$([uri]::EscapeDataString($using:Branch))" }
            if ($using:PullRequest) { $showUrl += "&pullRequest=$([uri]::EscapeDataString($using:PullRequest))" }
            try {
                $show = Invoke-RestMethod -Uri $showUrl -Headers $using:Headers -Method Get @(@{SkipCertificateCheck=$true}[$using:Global:SkipTLS])
                if ($show -and $show.sources) { $lines = @($show.sources | ForEach-Object { $_.code }) }
            } catch { }
        }
        if ($lines) {
            $start = [Math]::Max(1, $PSItem.Line - 3)
            $end   = [Math]::Min($lines.Length, $PSItem.Line + 3)
            $snippet = ($start..$end | ForEach-Object { "{0,4}: {1}" -f $_, $lines[$_-1] }) -join "`n"
        }
    }

    # normalize rule fields
    $ruleName = $rule?.name ?? $PSItem.RuleKey
    $descHtml = $rule?.htmlDesc ?? $rule?.mdDesc
    $desc     = Strip-Html $descHtml
    $reco     = if ($rule?.remediation) {
        Strip-Html ( ($rule.remediation.func ?? "") + " " + ($rule.remediation.gapDescription ?? "") )
    } elseif ($rule?.debtRemFnBaseEffort) {
        Strip-Html $rule.debtRemFnBaseEffort
    } else {
        $desc
    }

    [pscustomobject]@{
        File           = $PSItem.Component
        Line           = $PSItem.Line
        RuleKey        = $PSItem.RuleKey
        RuleName       = $ruleName
        Description    = $desc
        Recommendation = $reco
        CodeSnippet    = $snippet
        Severity       = $PSItem.Issue.severity
        Type           = $PSItem.Issue.type
        Message        = $PSItem.Issue.message
    }
} -ThrottleLimit $Throttle

# assemble and export
$branchOut = $Branch ? $Branch : "main"
$final = $results | Select-Object @{n='Project';e={$ProjectKey}},
                              @{n='Branch';e={$branchOut}},
                              File, Line, Severity, Type, RuleKey, RuleName, Message, Description, Recommendation, CodeSnippet
$final | Export-Csv -Path $OutputCsv -NoTypeInformation -Encoding UTF8
Write-Host "Export complete: $OutputCsv"
