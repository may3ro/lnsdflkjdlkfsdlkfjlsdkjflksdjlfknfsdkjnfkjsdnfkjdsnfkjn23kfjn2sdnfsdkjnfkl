# ====================================================================
# SonarQube ABAP Code Security Export (PS 5.1 safe)
# - No "$Var:" patterns; only -f formatting / concatenation
# ====================================================================

# ---- CONFIG ----
$SonarQubeUrl = "https://your-sonarqube-server"
$Token        = "YOUR_TOKEN"
$ProjectKey   = "your_project_key"
$OutputFile   = "SonarQube_ABAP_Security_Report.csv"

# ---- (optional) trust self-signed TLS for this session ----
# [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }

# ---- AUTH ----
$pair         = ($Token + ":")                                    # no interpolation
$encodedToken = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($pair))
$Headers      = @{ "Authorization" = ("Basic {0}" -f $encodedToken) }

# ---- HELPERS ----
function Invoke-GET {
    param([string]$Url)
    try {
        return Invoke-RestMethod -Uri $Url -Headers $Headers -Method Get -ErrorAction Stop
    } catch {
        $msg = if ($_.Exception) { $_.Exception.Message } else { ("" + $_) }
        Write-Warning ("HTTP GET failed: {0} -> {1}" -f $Url, $msg)
        return $null
    }
}

function Get-SonarQubeIssues {
    param([string]$ProjectKey)

    $PageSize  = 500
    $Page      = 1
    $AllIssues = @()

    do {
        $url = ("{0}/api/issues/search?componentKeys={1}&p={2}&ps={3}" -f `
                $SonarQubeUrl, [uri]::EscapeDataString($ProjectKey), $Page, $PageSize)
        $resp = Invoke-GET -Url $url
        if (-not $resp) { break }

        if ($resp.issues) { $AllIssues += $resp.issues }
        $total = [int]$resp.paging.total
        $Page++

    } while ($AllIssues.Count -lt $total)

    return $AllIssues
}

function Get-RuleDetails {
    param([string]$RuleKey)
    $url  = ("{0}/api/rules/show?key={1}" -f $SonarQubeUrl, [uri]::EscapeDataString($RuleKey))
    $resp = Invoke-GET -Url $url
    if ($resp -and $resp.rule) { return $resp.rule }
    Write-Warning ("Cannot retrieve rule {0}" -f $RuleKey)
    return $null
}

function Get-CodeSnippet {
    param([string]$ComponentKey, [int]$Line)

    if (-not $Line -or $Line -le 0) { return "" }

    $rawUrl  = ("{0}/api/sources/raw?key={1}" -f $SonarQubeUrl, [uri]::EscapeDataString($ComponentKey))
    $rawText = Invoke-GET -Url $rawUrl
    if (-not $rawText) { return "" }

    $lines = $rawText -split "`n"
    $start = [Math]::Max(1, $Line - 3)
    $end   = [Math]::Min($lines.Length, $Line + 3)

    $buf = New-Object System.Text.StringBuilder
    for ($i = $start; $i -le $end; $i++) {
        [void]$buf.AppendLine(("{0,4}: {1}" -f $i, $lines[$i-1]))
    }
    $buf.ToString().TrimEnd()
}

function Strip-Html {
    param([string]$s)
    if (-not $s) { return "" }
    (($s -replace '<[^>]+>', '') -replace '\s+', ' ').Trim()
}

# ---- MAIN ----
Write-Host ("Retrieving issues for project '{0}' ..." -f $ProjectKey)
$issues = Get-SonarQubeIssues -ProjectKey $ProjectKey

$result = @()

foreach ($issue in $issues) {
    # line number can be in .line or .textRange.startLine depending on SQ version
    $line = $null
    if ($issue.PSObject.Properties.Name -contains 'line' -and $issue.line) {
        $line = [int]$issue.line
    } elseif ($issue.PSObject.Properties.Name -contains 'textRange' -and $issue.textRange -and $issue.textRange.startLine) {
        $line = [int]$issue.textRange.startLine
    }

    $rule = Get-RuleDetails -RuleKey $issue.rule

    $ruleName = if ($rule -and $rule.name) { $rule.name } else { $issue.rule }
    $desc     = if ($rule -and $rule.htmlDesc) { Strip-Html $rule.htmlDesc } else { "" }

    # Best-effort recommendation text (varies by SonarQube version)
    $reco = ""
    if ($rule) {
        if ($rule.remediation) {
            $reco = Strip-Html (($rule.remediation.func + " " + $rule.remediation.gapDescription))
        } elseif ($rule.debtRemFnBaseEffort) {
            $reco = Strip-Html $rule.debtRemFnBaseEffort
        } else {
            $reco = $desc
        }
    }

    $snippet = if ($line) { Get-CodeSnippet -ComponentKey $issue.component -Line $line } else { "" }

    $result += [PSCustomObject]@{
        Project        = $ProjectKey
        File           = $issue.component
        Line           = $line
        Severity       = $issue.severity
        Type           = $issue.type
        RuleKey        = $issue.rule
        RuleName       = $ruleName
        Message        = $issue.message
        Description    = $desc
        Recommendation = $reco
        CodeSnippet    = $snippet
    }
}

Write-Host "Exporting to CSV..."
$result | Export-Csv -Path $OutputFile -NoTypeInformation -Encoding UTF8
Write-Host ("Export complete: {0}" -f $OutputFile)
