# ================================
# SonarQube ABAP Security Export
# Works with SonarQube 2025.x
# PowerShell 5.1 compatible
# ================================

# -------- CONFIG --------
$SonarQubeUrl = "http://localhost:9000"
$UserToken    = "YOUR_USER_TOKEN_WITH_SOURCE_ACCESS"
$ProjectKey   = "your_project_key"
$Branch       = ""          # e.g. "develop" or "" for main
$PullRequest  = ""          # e.g. "123" if exporting a PR; leave "" if not a PR
$OutputCsv    = "SonarQube_ABAP_Security_Report.csv"

# Optional: trust self-signed TLS
# [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }

# -------- AUTH --------
$pair         = ($UserToken + ":")
$encodedToken = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($pair))
$Headers      = @{ "Authorization" = ("Basic {0}" -f $encodedToken) }

# -------- HELPERS --------
function Add-QS {
    param([string]$url, [hashtable]$kv)
    if (-not $kv) { return $url }
    $parts = @()
    foreach ($k in $kv.Keys) {
        if ($kv[$k] -ne $null -and $kv[$k] -ne "") {
            $parts += ("{0}={1}" -f [uri]::EscapeDataString($k), [uri]::EscapeDataString([string]$kv[$k]))
        }
    }
    if ($parts.Count -eq 0) { return $url }
    if ($url -like "*?*") { return ($url + "&" + ($parts -join "&")) }
    else { return ($url + "?" + ($parts -join "&")) }
}

function GET {
    param([string]$url, [switch]$Quiet)
    try {
        return Invoke-RestMethod -Uri $url -Headers $Headers -Method Get -ErrorAction Stop
    } catch {
        if (-not $Quiet) {
            $msg = if ($_.Exception) { $_.Exception.Message } else { ("" + $_) }
            Write-Warning ("HTTP GET failed: {0} -> {1}" -f $url, $msg)
        }
        return $null
    }
}

function Get-ServerVersion {
    $u = ("{0}/api/server/version" -f $SonarQubeUrl)
    $r = GET $u -Quiet
    if ($r) { return [string]$r }
    return "unknown"
}

function Get-Issues {
    param([string]$ProjectKey)
    $all = @()
    $page = 1
    $ps = 500

    do {
        $base = ("{0}/api/issues/search" -f $SonarQubeUrl)
        $qs = @{
            componentKeys = $ProjectKey
            p            = $page
            ps           = $ps
        }
        if ($Branch -ne "")     { $qs["branch"] = $Branch }
        if ($PullRequest -ne ""){ $qs["pullRequest"] = $PullRequest }

        $url = Add-QS -url $base -kv $qs
        $resp = GET $url
        if (-not $resp) { break }

        if ($resp.issues) { $all += $resp.issues }
        $total = [int]$resp.paging.total
        $page++
    } while ($all.Count -lt $total)

    $all
}

function Get-Rule {
    param([string]$RuleKey)
    $base = ("{0}/api/rules/show" -f $SonarQubeUrl)
    $url  = Add-QS -url $base -kv @{ key = $RuleKey }
    $r = GET $url -Quiet
    if ($r -and $r.rule) { return $r.rule }
    Write-Warning ("Cannot retrieve rule {0}" -f $RuleKey)
    $null
}

function Strip-Html([string]$s) {
    if (-not $s) { return "" }
    (($s -replace '<[^>]+>', '') -replace '\s+', ' ').Trim()
}

function Get-Snippet {
    param([string]$ComponentKey, [int]$Line)

    if (-not $Line -or $Line -le 0) { return "" }

    # Try /sources/raw (fast)
    $rawBase = ("{0}/api/sources/raw" -f $SonarQubeUrl)
    $rawUrl  = Add-QS -url $rawBase -kv @{ key = $ComponentKey; branch = $Branch; pullRequest = $PullRequest }
    $raw     = GET $rawUrl -Quiet
    $lines = $null

    if ($raw) {
        $lines = $raw -split "`n"
    } else {
        # Fallback: /sources/show (JSON)
        $showBase = ("{0}/api/sources/show" -f $SonarQubeUrl)
        $showUrl  = Add-QS -url $showBase -kv @{ key = $ComponentKey; branch = $Branch; pullRequest = $PullRequest }
        $show     = GET $showUrl -Quiet
        if ($show -and $show.sources) {
            $lines = @()
            foreach ($row in $show.sources) { $lines += $row.code }
        } else {
            # Most likely 403 (missing "See Source Code")
            Write-Warning ("No source for component (permission?): {0}" -f $ComponentKey)
            return ""
        }
    }

    $start = [Math]::Max(1, $Line - 3)
    $end   = [Math]::Min($lines.Length, $Line + 3)

    $sb = New-Object System.Text.StringBuilder
    for ($i = $start; $i -le $end; $i++) {
        [void]$sb.AppendLine(("{0,4}: {1}" -f $i, $lines[$i-1]))
    }
    $sb.ToString().TrimEnd()
}

# -------- MAIN --------
$sv = Get-ServerVersion
Write-Host ("SonarQube server version: {0}" -f $sv)

# Token sanity check
$valUrl = ("{0}/api/authentication/validate" -f $SonarQubeUrl)
$val = GET $valUrl
if (-not $val -or -not $val.valid) {
    throw "Authentication failed. Check token/user permissions."
}

Write-Host ("Collecting issues for project '{0}'{1}{2} ..." -f `
    $ProjectKey, ($Branch -ne "" ? (" (branch=" + $Branch + ")") : ""), ($PullRequest -ne "" ? (" (PR=" + $PullRequest + ")") : ""))

$issues = Get-Issues -ProjectKey $ProjectKey
$result = @()

foreach ($i in $issues) {
    # line: issues API may return .line or .textRange.startLine
    $line = $null
    if ($i.PSObject.Properties.Name -contains 'line' -and $i.line) {
        $line = [int]$i.line
    } elseif ($i.PSObject.Properties.Name -contains 'textRange' -and $i.textRange -and $i.textRange.startLine) {
        $line = [int]$i.textRange.startLine
    }

    $rule = Get-Rule -RuleKey $i.rule

    # normalize rule fields across versions
    $ruleName = if ($rule -and $rule.name) { $rule.name } else { $i.rule }
    $descHtml = if ($rule -and $rule.htmlDesc) { $rule.htmlDesc } elseif ($rule -and $rule.mdDesc) { $rule.mdDesc } else { "" }
    $desc     = Strip-Html $descHtml

    # recommendation text (best effort across 2025.x)
    $reco = ""
    if ($rule) {
        if ($rule.remediation) {
            $gap = if ($rule.remediation.gapDescription) { $rule.remediation.gapDescription } else { "" }
            $reco = Strip-Html (($rule.remediation.func + " " + $gap))
        } elseif ($rule.debtRemFnBaseEffort) {
            $reco = Strip-Html $rule.debtRemFnBaseEffort
        } else {
            $reco = $desc
        }
    }

    $snippet = if ($line) { Get-Snippet -ComponentKey $i.component -Line $line } else { "" }

    $result += [PSCustomObject]@{
        Project        = $ProjectKey
        Branch         = ($Branch -ne "" ? $Branch : "main")
        File           = $i.component
        Line           = $line
        Severity       = $i.severity
        Type           = $i.type
        RuleKey        = $i.rule
        RuleName       = $ruleName
        Message        = $i.message
        Description    = $desc
        Recommendation = $reco
        CodeSnippet    = $snippet
    }
}

$result | Export-Csv -Path $OutputCsv -NoTypeInformation -Encoding UTF8
Write-Host ("Export complete: {0}" -f $OutputCsv)
